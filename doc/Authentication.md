The framework manages HTTP Authentication header in a special manner. The goal is to ease implementation burden on client applications while providing flexibility for customization. It offers the application an API to the header on two levels: per ByRest interface, and application global. Both are optional. 

Regardless how the header value is obtained, the framework always ignores null/empty/blank string. It only sets the header if the value is not null/empty/blank. This behavior applies to all the following cases.

# Per Interface
The following are the use cases supported by the framework on a per-interface basis.

## Basic Auth
To call a REST endpoint that requires HTTP Basic Auth, annotate the ByRest interface as below:

```java
@ByRest(value = "${api.url}", auth = @Auth(value = "${api.username}:${api.password}", type = Type.BASIC))
public interface AuthProxy {
    //...
}
```
Note the `@Auth` element: With the type set to `BASIC`, the value should be a plain-text string in the format of `"${username}:{$password}"`. The framework will encode the string according to HTTP specification before setting it as the value.

While the `@Auth` value does take hard-coded string, it's probably a good idea to use property variables and have the username and password configured by Spring.

## Bearer Token

For an endpoint that requires Bearer token authentication, annotate the interface as below:
```java
@ByRest(value = "${api.url}", auth = @Auth(value = "${api.token}", type = Type.BEARER))
public interface AuthProxy {
    //...
}
```

I.e., set `@Auth.type` to `BEARER`, `@Auth.value` straight toke string with no prefix. The framework will append necessary prefix to the value.

When specifying `@Auth` attribute, `@Auth.type` defaults to `BEARER` and can be omitted. I.e.,
```java
@ByRest(value = "${api.url}", auth = @Auth(value = "${api.token}"))
public interface AuthProxy {
    //...
}
```

Note the above is different from un-specified `@Auth` such as:
```java
@ByRest(value = "${api.url}")
public interface AuthProxy {
    //...
}
```
Un-specified `@Auth` has its type set to `DEFAULT`. See [here](#Default) for details on the default behavior.

## ASIS

If the application wishes to provide a value for Authentication header directly with no processing from the framework, it should set `@Auth.type` to `ASIS`:

```java
@ByRest(value = "${api.url}", auth = @Auth(value = "${api.auth}", type = Type.ASIS))
public interface AuthProxy {
    //...
}
```

For `ASIS` type, the framework takes the string and sets it to the header **as is** without any changes unless the string is blank. The framework ignores empty/blank string and will not set the header.

While `ASIS` gives the application direct access to the header value, it is a static mechanism. All requests generated by the interface will have the same value for the header. If the application wishes to provide a value dynamically, it should use `BEAN` type.

## Bean
To dynamically supply a value for the header, the application can use the following annotation:
```java
@ByRest(value = "${api.url}", auth = @Auth(value = "ApiAuthSupplier", type = Type.BEAN))
public interface AuthProxy {
    //...
}
```

When `@Auth.type` is set to `BEAN`, `@Auth.value` should be the name of a Spring bean of the type `java.util.function.Supplier`. For each out-going request, the framework looks for the bean with the given name and type, calls the supplier function to retrieve the value object, converts the object to `String` via `Object::toString`, sets the Authentication header to the string **as is**.

The framework calls the supplier once for each request so that the application can supply a value dynamically.

The framework sets the value as provided by the application without any change. The application should ensure it's in the correct format.

## Default
The default behavior, that is if the interface does not specify an `@Auth` value or has `@Auth.type` set to `DEFAULT`, is to follow the optional AuthenticationProvider bean. See [here](#AuthenticationProvider) for details on how Authentication header is handled for these interfaces at application/global scope. The following are examples of interfaces using the global provider:

```java
@ByRest(value = "${api.url}")
public interface AuthProxy {
    //...
}
```

```java
@ByRest(value = "${api.url}", auth = @Auth(value = "", type = Type.DEFAULT))
public interface AuthProxy {
    //...
}
```
In this case, `@Auth.value` is ignored.

# AuthenticationProvider
The application can optionally define a Spring bean of type `me.ehp246.aufrest.api.rest.AuthenticationProvider` that applies globally to all ByRest interfaces that have the AuthType set to DEFAULT. For each request made by these interfaces, the framework calls the bean for the value of Authentication header passing in the target URI as the parameter. The returned value is set to the header **as is** for the request with no further processing.

The bean is called once for each request, i.e., each invocation of a method on an interface.

If the bean does not exist, or if the returned String value is null/empty/blank, the request will not have Authentication header.

The global bean only applies to the interfaces that have AuthType at DEFAULT. It does not apply to the interfaces that have per-interface authentication applied.

The following is an example that implements Basic Auth for an endpoint only for the first call:
```java
@Bean
public AuthenticationProvider authProvider() {
    final var countRef = new AtomicReference<Integer>(0);
    return uri -> {
        if (uri.getPath().contains("basic-auth") && countRef.get() == 0) {
            countRef.getAndUpdate(i -> i + 1);
            return HttpUtils.basic("postman", "password");
        }
        return null;
    };
}
```